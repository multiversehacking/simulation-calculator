
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Simulation Probability Calculator</title>
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  body { margin: 24px; line-height: 1.45; }
  h1 { font-size: 1.25rem; margin-bottom: 8px; }
  h2 { font-size: 1.05rem; margin: 0 0 8px 0; }
  .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin-bottom: 16px; }
  .row { display: grid; grid-template-columns: 320px 1fr; gap: 10px; align-items: center; margin: 8px 0; }
  input[type="number"], select { width: 220px; padding: 6px 8px; border: 1px solid #bbb; border-radius: 8px; }
  .out { font-variant-numeric: tabular-nums; font-weight: 600; }
  .muted { color: #666; }
  .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .note { background: #f8f8f8; border-radius: 10px; padding: 12px; }
  .warn { color: #b45309; }
  input[type=number]::-webkit-inner-spin-button,
  input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
  input[type=number] { appearance: textfield; -moz-appearance: textfield; }
</style>
</head>
<body>
  <h1>Simulation Probability Calculator</h1>
<p><b>Created by Multiverse Hacking, 2025. <a href="https://MultiverseHacking.com" target="_blank">MultiverseHacking.com</a>.</b></p>
<div class="card note" style="margin-top:8px;">
<p><b>What this is:</b> A Drake-Equation–style calculator for simulation hypotheses. It estimates the chance that a randomly chosen <i>world</i> (universe) is <b>base</b> versus <b>simulated</b>. You set how many simulation-capable civilizations there are per base universe (<code>C</code>), the percentage that actually run simulations (<code>f_run</code>), how many simulations each running civ creates in the next layer (<code>k</code>), and how nesting works. For nesting, choose either a fixed maximum depth <code>d</code>, or a probabilistic mode where each simulation is allowed to spawn the next layer with probability <code>p_allow</code>. In probabilistic mode the key quantity is <code>m = k · p_allow</code> (the mean branching factor). If <code>m ≥ 1</code> and infinite nesting is allowed, the expected number of simulated worlds diverges and the probability of a base world goes to zero.</p>
<p><b>How to read the outputs:</b> <code>S</code> is the expected number of simulated worlds per running civilization. <code>C · (f_run/100) · S</code> is the expected sim-to-base world ratio. <code>P(base&nbsp;world)</code> and <code>P(sim&nbsp;world)</code> are the probabilities for a random world; we also show <b>Odds</b> as “1 in N.” The lines for <code>m</code> and the threshold <code>p_allow* = 1/k</code> indicate whether you are below or above the branching point; near that threshold, probabilities can shift dramatically.</p>
</div>

  <div class="card note">
    <b>World-level prior:</b> probability a randomly chosen world (base or simulated) is <b>base</b>.
    <div style="margin-top:6px">
      <b>Fixed-depth:</b> <code>S = k + k^2 + ... + k^d = k(1-k^d)/(1-k)</code> (or <code>S=d</code> if <code>k=1</code>)<br/>
      <b>Probabilistic nesting:</b> per-layer allow probability <code>p_allow</code>, mean branching <code>m = k·p_allow</code>.<br/>
      Capped D: <code>S = k · (1 - m^D)/(1 - m)</code> (or <code>S=kD</code> if <code>m=1</code>)<br/>
      Infinite: <code>S = k/(1 - m)</code> if <code>m &lt; 1</code>; <span class="warn">diverges</span> if <code>m ≥ 1</code>.
    </div>
    <div style="margin-top:6px"><code>P(base\ world) = 1 / (1 + C · (f_run/100) · S)</code></div>
  </div>

  <div class="grid-2">
    <div class="card">
      <h2>Inputs</h2>
      <div class="row">
        <label for="C">C: sim-capable civilizations per base universe</label>
        <input id="C" type="number" inputmode="decimal" value="1" min="0" step="1" oninput="compute()" onchange="compute()">
      </div>
      <div class="row">
        <label for="frun">f_run (%): % of civs that run simulations</label>
        <input id="frun" type="number" inputmode="decimal" value="10" min="0" max="100" step="0.1" oninput="compute()" onchange="compute()">
      </div>
      <div class="row">
        <label for="k">k: simulated universes per running civ (first layer)</label>
        <input id="k" type="number" inputmode="decimal" value="10" min="0" step="1" oninput="compute()" onchange="compute()">
      </div>

      <div class="row">
        <label for="nestmode">Nesting mode</label>
        <select id="nestmode" oninput="compute()" onchange="compute()">
          <option value="fixed" selected>Fixed depth d</option>
          <option value="prob_cap">Probabilistic (p_allow), capped at D</option>
          <option value="prob_inf">Probabilistic (p_allow), infinite if m&lt;1</option>
        </select>
      </div>

      <div id="fixed-block">
        <div class="row">
          <label for="d">d: maximum nesting depth (layers)</label>
          <input id="d" type="number" inputmode="decimal" value="3" min="1" step="1" oninput="compute()" onchange="compute()">
        </div>
      </div>

      <div id="prob-block" style="display:none">
        <div class="row">
          <label for="pallow">p_allow (%): probability a sim may spawn the next layer</label>
          <input id="pallow" type="number" inputmode="decimal" value="80" min="0" max="100" step="0.1" oninput="compute()" onchange="compute()">
        </div>
        <div class="row" id="caprow" style="display:none">
          <label for="D">D: cap on layers (for prob. capped)</label>
          <input id="D" type="number" inputmode="decimal" value="5" min="1" step="1" oninput="compute()" onchange="compute()">
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div class="muted" id="status" style="margin-bottom:8px;">Last calculated: —</div>
      <div class="row"><div class="muted">S (expected simulated worlds per running civ):</div><div class="out" id="S">—</div></div>
      <div class="row"><div class="muted">C · (f_run/100) · S:</div><div class="out" id="CFS">—</div></div>
      <div class="row"><div class="muted">m = k · p_allow (prob. modes):</div><div class="out" id="m_val">—</div></div>
      <div class="row"><div class="muted">Threshold p_allow* = 1/k:</div><div class="out" id="pthresh">—</div></div>
      <div class="row"><div class="muted">P(base world) = 1 / (1 + CFS):</div><div class="out" id="pbase">—</div></div>
      <div class="row"><div class="muted">P(sim world) = 1 − P(base):</div><div class="out" id="psim">—</div></div>
      <div class="row"><div class="muted">Odds our universe is base:</div><div class="out" id="odds_base">—</div></div>
      <div id="warn" class="warn" style="display:none;margin-top:6px;">Warning: m ≥ 1 → infinite probabilistic nesting diverges; S is effectively unbounded, pushing P(base) → 0.</div>
    </div>
  </div>

<script>
function fmt(x) {
  if (!isFinite(x)) return "—";
  if (Math.abs(x) >= 1e6 || Math.abs(x) < 1e-4) return x.toExponential(6);
  return x.toLocaleString(undefined, { maximumFractionDigits: 6 });
}
function fmtExp(x) {
  if (!isFinite(x)) return "—";
  return x.toExponential(12);
}
function fmtIntWithCommas(n) { return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ","); }
function fmtOneInN(p) {
  if (!isFinite(p) || p <= 0) return "1 in ∞";
  if (p >= 1) return "1 in 1";
  const n = 1 / p;
  if (n > 1e12) return "1 in " + n.toExponential(4);
  return "1 in " + fmtIntWithCommas(Math.round(n));
}
function clamp(x, lo, hi) {
  if (isNaN(x)) return NaN;
  if (lo !== null && x < lo) return lo;
  if (hi !== null && x > hi) return hi;
  return x;
}
function fmtProb(x) {
  if (!isFinite(x)) return "—";
  if (x < 0) x = 0;
  if (x > 1) x = 1;
  if (x > 0 && x < 1e-12) return x.toExponential(12);
  let s = x.toFixed(12);
  s = s.replace(/\\.?0+$/,''); 
  if (s.indexOf('.') === -1 && x < 1 && x > 0) s += '.0';
  return s;
}
function compute() {
  const C = Math.max(0, parseFloat(document.getElementById('C').value));
  const frun = Math.max(0, Math.min(100, parseFloat(document.getElementById('frun').value))) / 100.0;
  const k = Math.max(0, parseFloat(document.getElementById('k').value));
  const nestmode = document.getElementById('nestmode').value;

  document.getElementById('fixed-block').style.display = (nestmode === 'fixed') ? 'block' : 'none';
  document.getElementById('prob-block').style.display = (nestmode !== 'fixed') ? 'block' : 'none';
  document.getElementById('caprow').style.display = (nestmode === 'prob_cap') ? 'grid' : 'none';

  let S = NaN;
  let warn = false;
  let m = NaN;
  let pthresh = (k>0)? (1/k) : NaN;

  if (nestmode === 'fixed') {
    const d = Math.max(1, parseInt(document.getElementById('d').value, 10) || 1);
    if (Math.abs(1 - k) < 1e-12) S = d;
    else S = k * (1 - Math.pow(k, d)) / (1 - k);
  } else {
    const pallow = Math.max(0, Math.min(100, parseFloat(document.getElementById('pallow').value))) / 100.0;
    m = k * pallow;
    if (nestmode === 'prob_cap') {
      const D = Math.max(1, parseInt(document.getElementById('D').value, 10) || 1);
      if (Math.abs(1 - m) < 1e-12) S = k * D;
      else S = k * (1 - Math.pow(m, D)) / (1 - m);
    } else { // prob_inf
      if (m < 1) S = k / (1 - m);
      else { S = Infinity; warn = true; }
    }
  }

  const CFS = C * frun * S;
  const pbase = 1 / (1 + CFS);
  const psim = 1 - pbase;

  document.getElementById('S').textContent = fmt(S);
  document.getElementById('CFS').textContent = fmt(CFS);
  document.getElementById('m_val').textContent = isNaN(m) ? '—' : fmt(m);
  document.getElementById('pthresh').textContent = isNaN(pthresh) ? '—' : (pthresh).toExponential(6);
  document.getElementById('pbase').textContent = fmtProb(pbase);
  document.getElementById('psim').textContent = fmtProb(psim);
  document.getElementById('odds_base').textContent = fmtOneInN(pbase);
  document.getElementById('status').textContent = "Last calculated: " + new Date().toLocaleString();
  document.getElementById('warn').style.display = warn ? 'block' : 'none';
}
window.addEventListener('DOMContentLoaded', compute);
</script>
</body>
</html>
